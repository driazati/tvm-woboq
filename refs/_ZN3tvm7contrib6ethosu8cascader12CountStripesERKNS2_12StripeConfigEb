<dec f='tvm/contrib/ethosu/cascader/stripe_config.h' l='204' type='std::map&lt;std::vector&lt;int&gt;, int&gt; tvm::contrib::ethosu::cascader::CountStripes(const tvm::contrib::ethosu::cascader::StripeConfig &amp; stripe_config, bool enable_sliding_window)'/>
<doc f='tvm/contrib/ethosu/cascader/stripe_config.h' l='180'>/*!
 * \brief Count the number of stripes of each shape that are executed for a given
 StripeConfig.
 * \param stripe_config The StripeConfig to count the stripes for.
 * \param enable_sliding_window Whether to assume the sliding window optimization.
 * \return A map between stripe shapes and the number of stripes of that shape that need
 * executing.
 * \note If the StripeConfig were to split an (8, 8) tensor into (4, 4) stripes with
 * (4, 4) striding, then this function will return {(4, 4): 4} indicating that 4 (4, 4)
 * stripes will be executed. If instead an (8, 8) were striped using (5, 5) stripes
 * with (5, 5) striding, this function would return:
 *
 * {
 *   (5, 5): 1,
 *   (3, 5): 1,
 *   (5, 3): 1,
 *   (3, 3): 1,
 * }
 *
 * This is because some of the stripes will exceed the extent of the tensor and so only part
 * of them will need executing. Therefore, CountStripes will return the exact number of each
 * shape of stripe that is executed, accounting for edge and overlap behaviour which is not
 * explicit in the StripeConfig alone.
 */</doc>
<use f='tvm/contrib/ethosu/cascader/parts/ethosu.cc' l='58' u='c' c='_ZN3tvm7contrib6ethosu8cascader14EthosuPartNode12GetBytesReadERKSt6vectorIiSaIiEES8_'/>
<use f='tvm/contrib/ethosu/cascader/plan_generator.cc' l='321' u='c' c='_ZN3tvm7contrib6ethosu8cascader17GetCopyCyclesHintERKNS2_12TensorConfigE'/>
<def f='tvm/contrib/ethosu/cascader/stripe_config.cc' l='60' ll='101' type='std::map&lt;std::vector&lt;int&gt;, int&gt; tvm::contrib::ethosu::cascader::CountStripes(const tvm::contrib::ethosu::cascader::StripeConfig &amp; stripe_config, bool enable_sliding_window = false)'/>
<use f='tvm/contrib/ethosu/cascader/stripe_config.cc' l='106' u='c'/>
