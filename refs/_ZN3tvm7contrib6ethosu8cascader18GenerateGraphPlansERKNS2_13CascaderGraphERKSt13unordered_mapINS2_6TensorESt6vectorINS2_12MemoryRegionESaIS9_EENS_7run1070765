<dec f='tvm/contrib/ethosu/cascader/plan_generator.h' l='103' type='std::unordered_map&lt;std::vector&lt;Part&gt;, std::vector&lt;Plan&gt;&gt; tvm::contrib::ethosu::cascader::GenerateGraphPlans(const tvm::contrib::ethosu::cascader::CascaderGraph &amp; graph, const tvm::contrib::ethosu::cascader::HomeMap &amp; home_map, const tvm::contrib::ethosu::cascader::CascaderOptions &amp; options)'/>
<def f='tvm/contrib/ethosu/cascader/plan_generator.cc' l='448' ll='557' type='std::unordered_map&lt;std::vector&lt;Part&gt;, std::vector&lt;Plan&gt;&gt; tvm::contrib::ethosu::cascader::GenerateGraphPlans(const tvm::contrib::ethosu::cascader::CascaderGraph &amp; graph, const std::unordered_map&lt;Tensor, std::vector&lt;MemoryRegion&gt;, ObjectPtrHash, ObjectPtrEqual&gt; &amp; home_map, const tvm::contrib::ethosu::cascader::CascaderOptions &amp; options)'/>
<use f='tvm/contrib/ethosu/cascader/plan_generator.cc' l='598' u='c'/>
<doc f='tvm/contrib/ethosu/cascader/plan_generator.h' l='77'>/*!
 * \brief Generate pareto optimal Plans for a Graph.
 * \param graph The Graph to generate Plans for.
 * \param home_map The Tensor homing map defining valid memory homes for Tensors.
 * \param options The configuration options with which to run the generator.
 * \return A map between Part groups and a list of pareto optimal Plans which cover that group.
 * \note This algorithm does the following:
 *
 * Iterate Part-by-Part in a reversed topological ordering (starting at the output Parts and
 * working towards the input Parts).
 *
 * For each Part:
 *  1. Determine the possible StripeConfigs we might want to use to stripe the Part using
 *     GenerateOutputStripeConfigs.
 *  2. Additionally, collect all the StripeConfigs of open Plans that could connect to this
 *     Part (i.e. the Plan has an open TensorConfig for the Part&apos;s output Tensor).
 *  3. Use these two lists of StripeConfigs to produce single Part Plans with GenerateSinglePlans.
 *  4. For the generated Plans that have an open output TensorConfig, try and merge these into
 *     existing Plans which share an open input TensorConfig.
 *  5. All Plans are then indexed by both the Part group they cover and their open TensorConfigs.
 *  6. Plans which cover the same Part group and share the same open TensorConfigs are culled
 *     using ParetoCullPlans.
 *
 * Once every Part has been visited, return the Plans with no open TensorConfigs indexed by Part
 * group.
 */</doc>
<use f='tvm/contrib/ethosu/cascader/proposal_generator.cc' l='189' u='c' c='_ZN3tvm7contrib6ethosu8cascader17GenerateProposalsERKNS2_13CascaderGraphERKSt13unordered_mapINS2_6TensorESt6vectorINS2_12MemoryRegionESaIS9_EENS_7runt15189700'/>
