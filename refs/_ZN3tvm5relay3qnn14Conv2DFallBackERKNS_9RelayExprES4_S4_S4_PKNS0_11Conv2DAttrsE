<def f='tvm/relay/qnn/op/convolution.cc' l='193' ll='215' type='tvm::relay::Expr tvm::relay::qnn::Conv2DFallBack(const tvm::relay::Expr &amp; data, const tvm::relay::Expr &amp; weight, const tvm::relay::Expr &amp; input_zero_point, const tvm::relay::Expr &amp; kernel_zero_point, const tvm::relay::Conv2DAttrs * param)'/>
<use f='tvm/relay/qnn/op/convolution.cc' l='776' u='c' c='_ZN3tvm5relay3qnn21QnnConv2DCanonicalizeERKNS_5AttrsERKNS_7runtime5ArrayINS_9RelayExprEvEERKNS6_INS_4TypeEvEE'/>
<doc f='tvm/relay/qnn/op/convolution.cc' l='180'>/*
 * \brief Fallback to simpler lowering for dilation (when non-zero kernel point) or grouped conv.
 * \param data The input expr.
 * \param weight The weight expr.
 * \param input_zero_point The input zero point expr.
 * \param kernel_zero_point The kernel zero point expr.
 * \param param The qnn conv2d attributes.
 * \return The fallback lowered sequence of Relay expr.
 * \note In case of dilation with non-zero kernel zero point, normal lowering would require a
 * dilated pool. Since, we don&apos;t have dilated pool, we fallback to a simpler sequence of Relay
 * operations. This will potentially lead to performance degradation as the convolution is called on
 * int32 tensors instead of int8 tensors.
 */</doc>
