<dec f='tvm/relay/collage/prune_candidates.h' l='65' type='std::vector&lt;CandidatePartition&gt; tvm::relay::collage::PruneCandidates(const tvm::relay::collage::DataflowGraph &amp; dataflow_graph, const std::vector&lt;CandidatePartition&gt; &amp; initial_candidates)'/>
<use f='tvm/relay/collage/candidate_partition_index.cc' l='44' u='c' c='_ZN3tvm5relay7collage23CandidatePartitionIndex5IndexERKNS_7runtime5ArrayINS1_13PartitionSpecEvEE'/>
<doc f='tvm/relay/collage/prune_candidates.h' l='37'>/*!
 * \brief Returns \p initial_candidates with all unnecessary candidates pruned.
 *
 * We prune according to the following two heuristics:
 * 1. Given partitions (A, target) and (B, target) then
 *    cost(A union B, target) &lt; cost(A, target) + cost(B, target).
 *    That is, there&apos;s no use estimating the cost of small partitions when a larger partition
 *    containing them is also available. More precisely, call a partition &apos;maximal&apos; if it is
 *    not contained by any other partition for the same target. Then we want to prefer maximal
 *    candidates when searching.
 * 2. Given maximal partitions (A union B, target) and (A union B, target&apos;) where
 *    target != target&apos;, then min(cost(A union B, target), cost(A union B, target&apos;)) &lt;
 *    min(cost(A, target) + cost(B, target&apos;), cost(A, target&apos;) + cost(B, target)).
 *    That is, there&apos;s no use estimating cross-combinations of partitions which are not maximal.
 *
 * However, we can&apos;t prune a non-maximal candidate if it will make some other maximal candidate
 * unreachable during the Collage search. We achieve this by iterating until fixed point:
 *  - Find maximal candidates of current set of candidates.
 *  - Add those maximal candidates to the output &apos;pruned&apos; set.
 *  - If any two candidates in the &apos;pruned&apos; set intersect without being equal, remove those from
 *    the current set of candidates and go around again. That will force more candidates to
 *    be considered &apos;maximal&apos;.
 * That over-approximates the true necessary candidates but is at least simple.
 *
 * CAUTION: This is pretty experimental. The above heuristics won&apos;t always be safe, and I don&apos;t
 * have a proof the pruned candidate set won&apos;t lead to &apos;No candidate was found covering
 * sub-expression...&apos; errors in Partitioner::Partition().
 */</doc>
<def f='tvm/relay/collage/prune_candidates.cc' l='175' ll='214' type='std::vector&lt;CandidatePartition&gt; tvm::relay::collage::PruneCandidates(const tvm::relay::collage::DataflowGraph &amp; dataflow_graph, const std::vector&lt;CandidatePartition&gt; &amp; initial_candidates)'/>
