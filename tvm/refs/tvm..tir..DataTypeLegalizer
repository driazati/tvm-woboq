<inh f='tvm/include/tvm/tir/stmt_functor.h' l='315' c='tvm::tir::StmtExprMutator'/>
<def f='tvm/include/tvm/tir/data_type_rewriter.h' l='50' ll='82'/>
<ovr f='tvm/include/tvm/tir/data_type_rewriter.h' l='93' c='tvm::tir::IndexDataTypeRewriter'/>
<use f='tvm/include/tvm/tir/data_type_rewriter.h' l='93'/>
<use f='tvm/include/tvm/tir/data_type_rewriter.h' l='95'/>
<size>80</size>
<doc f='tvm/include/tvm/tir/data_type_rewriter.h' l='34'>/*!
 * \brief Legalize the data types of expressions to make sure they are consistent with other
 * parts of the program.
 *
 * It enforces the following rules:
 * - The data type of the index variable in a loop must be consistent with the data type of the loop
 *  bounds.
 * - The data type of the binary and ternary expressions must be consistent with the data types of
 * each of their operands.
 * - The data type of the bounds and binding values of block iter vars must be consistent with the
 * data type of the block iter vars.
 *
 * Usually we enforce the consistency of data types when constructing the IR nodes. However, such
 * inconsistency may happen as a result of IR mutation in some passes. This class can be used as
 * base class of such passes to ensure the consistency of data types.
 */</doc>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitStmt_EPKNS0_7ForNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitStmt_EPKNS0_12AttrStmtNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitStmt_EPKNS0_16BlockRealizeNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitStmt_EPKNS0_9BlockNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_10SelectNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_8RampNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_7AddNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_7SubNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_7MulNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_7DivNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_7ModNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_12FloorDivNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_12FloorModNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_7MinNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_7MaxNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_6EQNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_6NENodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_6LTNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_6LENodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_6GTNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_6GENodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_8CallNodeE'/>
<fun r='_ZN3tvm3tir17DataTypeLegalizer10VisitExpr_EPKNS0_8CastNodeE'/>
<mbr r='tvm::tir::DataTypeLegalizer::ivmap_' o='192' t='std::unordered_map&lt;const IterVarNode *, IterVar&gt;'/>
<ovr f='tvm/src/tir/ir/stmt_functor.cc' l='813' c='tvm::tir::IRSubstituteWithDataTypeLegalization'/>
<use f='tvm/src/tir/ir/stmt_functor.cc' l='813'/>
<size>80</size>
