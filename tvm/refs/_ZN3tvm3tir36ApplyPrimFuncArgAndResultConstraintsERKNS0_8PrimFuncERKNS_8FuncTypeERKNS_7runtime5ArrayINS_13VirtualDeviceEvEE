<dec f='tvm/src/tir/analysis/device_constraint_utils.h' l='91' type='tvm::tir::PrimFunc tvm::tir::ApplyPrimFuncArgAndResultConstraints(const tvm::tir::PrimFunc &amp; prim_func, const tvm::FuncType &amp; relay_func_type, const Array&lt;tvm::VirtualDevice&gt; &amp; arg_and_result_virtual_devices)'/>
<use f='tvm/src/relay/transforms/device_planner.cc' l='964' u='c' c='_ZN3tvm5relay9transform12_GLOBAL__N_114DeviceCapturer14UpdatePrimFuncERKNS_9GlobalVarERKNS_3tir8PrimFuncE'/>
<doc f='tvm/src/tir/analysis/device_constraint_utils.h' l='82'>/*
 * \brief Returns \p prim_func written to capture the memory (aka storage) scope constraints
 * for each of the \p prim_func&apos;s parameters given by \p arg_and_result_virtual_devices. However,
 * \p arg_and_result_virtual_devices should be w.r.t. the \p prim_func&apos;s representation as a Relay
 * \p Function of \p relay_func_type before lowering and conversion to DPS.
 *
 * CAUTION: This is experimental. The resulting \p PrimFunc may not have fully accounted for all
 * new memory scopes.
 */</doc>
<def f='tvm/src/tir/analysis/device_constraint_utils.cc' l='496' ll='501' type='tvm::tir::PrimFunc tvm::tir::ApplyPrimFuncArgAndResultConstraints(const tvm::tir::PrimFunc &amp; prim_func, const tvm::FuncType &amp; relay_func_type, const Array&lt;tvm::VirtualDevice&gt; &amp; arg_and_result_virtual_devices)'/>
<use f='tvm/src/tir/analysis/device_constraint_utils.cc' l='511' u='c'/>
