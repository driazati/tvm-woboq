<dec f='tvm/src/support/scalars.h' l='61' type='tvm::IntImm tvm::support::ValueToIntImm(int64_t value, int width)'/>
<use f='tvm/src/parser/tokenizer.h' l='243' u='c' c='_ZN3tvm6parser9Tokenizer11ParseNumberEbbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
<use f='tvm/src/parser/tokenizer.h' l='248' u='c' c='_ZN3tvm6parser9Tokenizer11ParseNumberEbbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
<use f='tvm/src/parser/tokenizer.h' l='254' u='c' c='_ZN3tvm6parser9Tokenizer11ParseNumberEbbNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
<doc f='tvm/src/support/scalars.h' l='56'>/*!
 * \brief Returns TIR immediate for given value and width. Result will be null if value is
 * out of range in width. Note however for floating point we don&apos;t check if the value is
 * representable without loss of precision.
 */</doc>
<def f='tvm/src/support/scalars.cc' l='156' ll='175' type='tvm::IntImm tvm::support::ValueToIntImm(int64_t value, int width)'/>
