<def f='tvm/src/tir/ir/specialize.cc' l='279' ll='334' type='void tvm::tir::UpdateSpecializeVarMap(const tvm::tir::PrimFunc &amp; func, const tvm::tir::Var &amp; param, const tvm::tir::Buffer &amp; specific_buf, tvm::tir::VarMap * var_map)'/>
<use f='tvm/src/tir/ir/specialize.cc' l='362' u='c' c='_ZN3tvm3tir10SpecializeENS0_8PrimFuncERKNS_7runtime3MapINS0_3VarENS2_9ObjectRefEvvEE'/>
<doc f='tvm/src/tir/ir/specialize.cc' l='262'>/*!
 * \brief Update Specialize var map with buffer matching.
 * \param func The function to be specialized.
 * \param param The given function parameter
 * \param specific_buf The matching buffer.
 * \param var_map The var mapping to be updated.
 * \note This function will match target buffer&apos;s shape, strides and element_offset
 *   For example, we define a buffer in PrimFunc:
 *   A = T.match_buffer(a, [m, n])
 *
 *   Then we match it with a buffer B =  tir.decl_buffer((8, 16))
 *
 *   It means we have two var mappings here: m = 8 and n = 16
 *
 *   If the buffer signature is not a Var, the mapping will fail.
 *   e.g. A = T.match_buffer(a, [m * 2, n + 1])
 */</doc>
