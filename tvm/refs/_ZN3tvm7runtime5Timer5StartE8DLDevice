<dec f='tvm/include/tvm/runtime/profiling.h' l='140' type='static tvm::runtime::Timer tvm::runtime::Timer::Start(tvm::Device dev)'/>
<doc f='tvm/include/tvm/runtime/profiling.h' l='88'>/*!
   * \brief Get a device specific timer.
   * \param dev The device to time.
   * \return A `Timer` that has already been started.
   *
   * Use this function to time runtime of arbitrary regions of code on a specific
   * device. The code that you want to time should be running on the device
   * otherwise the timer will not return correct results. This is a lower level
   * interface than TimeEvaluator and only runs the timed code once
   * (TimeEvaluator runs the code multiple times).
   *
   * A default timer is used if a device specific one does not exist. This
   * timer performs synchronization between the device and CPU, which can lead
   * to overhead in the reported results.
   *
   * Example usage:
   * \code{.cpp}
   * Timer t = Timer::Start(Device::cpu());
   * my_long_running_function();
   * t-&gt;Stop();
   * ... // some more computation
   * int64_t nanosecs = t-&gt;SyncAndGetElapsedNanos() // elapsed time in nanoseconds
   * \endcode
   *
   * To add a new device-specific timer, register a new function
   * &quot;profiler.timer.my_device&quot; (where `my_device` is the `DeviceName` of your
   * device). This function should accept a `Device` and return a new `Timer`
   * that has already been started.
   *
   * For example, this is how the CPU timer is implemented:
   * \code{.cpp}
   *  class CPUTimerNode : public TimerNode {
   *   public:
   *    virtual void Start() { start_ = std::chrono::high_resolution_clock::now(); }
   *    virtual void Stop() { duration_ = std::chrono::high_resolution_clock::now() - start_; }
   *    virtual int64_t SyncAndGetElapsedNanos() { return duration_.count(); }
   *    virtual ~CPUTimerNode() {}
   *
   *    static constexpr const char* _type_key = &quot;CPUTimerNode&quot;;
   *    TVM_DECLARE_FINAL_OBJECT_INFO(CPUTimerNode, TimerNode);
   *
   *   private:
   *    std::chrono::high_resolution_clock::time_point start_;
   *    std::chrono::duration&lt;int64_t, std::nano&gt; duration_;
   *  };
   *  TVM_REGISTER_OBJECT_TYPE(CPUTimerNode);
   *
   *  TVM_REGISTER_GLOBAL(&quot;profiling.timer.cpu&quot;).set_body_typed([](Device dev) {
   *    return Timer(make_object&lt;CPUTimerNode&gt;());
   *  });
   * \endcode
   */</doc>
<use f='tvm/src/runtime/graph_executor/debug/graph_executor_debug.cc' l='208' u='c' c='_ZN3tvm7runtime18GraphExecutorDebug9RunOpHostEi'/>
<def f='tvm/src/runtime/profiling.cc' l='92' ll='103' type='static tvm::runtime::Timer tvm::runtime::Timer::Start(tvm::Device dev)'/>
<use f='tvm/src/runtime/profiling.cc' l='105' u='r'/>
<use f='tvm/src/runtime/profiling.cc' l='143' u='c' c='_ZN3tvm7runtime9profiling8Profiler9StartCallENS0_6StringE8DLDeviceSt13unordered_mapINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEENS0_9ObjectRef8712940'/>
<use f='tvm/src/runtime/profiling.cc' l='884' u='c' c='_ZN3tvm7runtime9profiling17WrapTimeEvaluatorENS0_10PackedFuncE8DLDeviceiiiiiS2_'/>
