<inh f='tvm/include/tvm/tir/stmt_functor.h' l='300' c='tvm::tir::StmtExprVisitor'/>
<def f='tvm/src/tir/schedule/primitive/layout_transformation.cc' l='66' ll='704'/>
<use f='tvm/src/tir/schedule/primitive/layout_transformation.cc' l='97' c='_ZN3tvm3tir22TransformLayoutPlanner4PlanENS0_5BlockENS0_6BufferES3_NS0_8IndexMapES4_NS_8PrimExprENS_7runtime8OptionalIS4_EE'/>
<use f='tvm/src/tir/schedule/primitive/layout_transformation.cc' l='597' c='_ZN3tvm3tir22TransformLayoutPlanner11BindLoopVarC1EPS1_NS0_3ForE'/>
<use f='tvm/src/tir/schedule/primitive/layout_transformation.cc' l='612'/>
<use f='tvm/src/tir/schedule/primitive/layout_transformation.cc' l='618' c='_ZN3tvm3tir22TransformLayoutPlanner22BindVariableDefinitionC1EPS1_NS0_3VarENS_8PrimExprE'/>
<use f='tvm/src/tir/schedule/primitive/layout_transformation.cc' l='645'/>
<use f='tvm/src/tir/schedule/primitive/layout_transformation.cc' l='650' c='_ZN3tvm3tir22TransformLayoutPlanner16BindBlockRealizeC1EPS1_NS0_12BlockRealizeE'/>
<use f='tvm/src/tir/schedule/primitive/layout_transformation.cc' l='665'/>
<size>192</size>
<doc f='tvm/src/tir/schedule/primitive/layout_transformation.cc' l='29'>/*! \brief Planning stage prior to rewriting in TransformLayoutRewriter
 *
 * There are four ways that transformation may be handled.  Each
 * updates the buffer shape and the indices used to acces the buffer
 * in BufferStore/BufferLoad nodes, but differ in how they handle the
 * `pad_value`.  In order of preference, the different strategies are
 * as follows:
 *
 * 1. NoPaddingRequired.  The transformation does not introduce
 * padding, so only local changes to update the indices of
 * BufferLoad/BufferStore nodes are required.  No blocks are added,
 * removed, or replaced.
 *
 * 2. ProloguePlan.  The transformation introduces padding, but the
 * analyzed block has no write stages for the transformed buffer.
 * This buffer is an input and the caller is responsible for ensuring
 * that the padding contains the specified `pad_value`.  The generated
 * prologue contains `builtin::assume()` calls that will expose this
 * known value during scheduling/simplification, but will be removed
 * during lowering.
 *
 * 3. ReplacementPlan.  The transformation introduces padding, has at
 * least one write stage for the transformed buffer, and at least one
 * of those write stages writes to all pre-transformation indices
 * following a row-major traversal.  These write stage is rewritten to
 * be row-major traversals of the post-transformation indices, with a
 * `tir::if_then_else` call to write either the specified `pad_value`
 * into padding or the computed value into non-padding.
 *
 * 4. EpiloguePlan.  The transformation introduces padding, has at
 * least one write stage for the transformed buffer, but no write
 * stage can be rewritten to use `tir::if_then_else`.  The
 * transformation still requires the `pad_value` to be written into
 * the padding, so a new block is inserted after the last write stage
 * to explicitly fill the padding.
 *
 */</doc>
<fun r='_ZN3tvm3tir22TransformLayoutPlanner10VisitStmt_EPKNS0_7ForNodeE'/>
<fun r='_ZN3tvm3tir22TransformLayoutPlanner10VisitStmt_EPKNS0_11LetStmtNodeE'/>
<fun r='_ZN3tvm3tir22TransformLayoutPlanner10VisitStmt_EPKNS0_16BlockRealizeNodeE'/>
<fun r='_ZN3tvm3tir22TransformLayoutPlanner10VisitStmt_EPKNS0_15BufferStoreNodeE'/>
