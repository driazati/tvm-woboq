<dec f='tvm/include/tvm/auto_scheduler/transform_step.h' l='821' type='void tvm::auto_scheduler::ComputeAtStepNode::ApplyToState(tvm::auto_scheduler::State * state) const'/>
<doc f='tvm/include/tvm/auto_scheduler/transform_step.h' l='813'>/*!
   * \brief Apply the current step to State.
   * \param state A mutable pointer to state, which will be updated.
   * \note After compute_at, we need careful dependency analysis to compute the accurate bound
   * information. However, it is relatively expensive and complicated, so we just fill &quot;None&quot; as
   * bound for the newly created iterators.
   * Call ComputeDAG::InferBound on the updated state if you need the complete bound information.
   */</doc>
<use f='tvm/src/auto_scheduler/loop_state.cc' l='318' u='c' c='_ZN3tvm14auto_scheduler5State10compute_atEiiRKNS0_8IteratorE'/>
<use f='tvm/src/auto_scheduler/transform_step.cc' l='236' u='c' c='_ZN3tvm14auto_scheduler16StepApplyToStateERKNS0_4StepEPNS0_5StateERKNS0_10ComputeDAGE'/>
<def f='tvm/src/auto_scheduler/transform_step.cc' l='1315' ll='1331' type='void tvm::auto_scheduler::ComputeAtStepNode::ApplyToState(tvm::auto_scheduler::State * state) const'/>
