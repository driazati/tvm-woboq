<dec f='tvm/src/relay/qnn/utils.h' l='183' type='tvm::relay::Expr tvm::relay::qnn::FixedPointMultiplyToNearest(tvm::relay::Expr tensor, double multiplier, const Array&lt;tvm::relay::IndexExpr&gt; &amp; input_shape)'/>
<doc f='tvm/src/relay/qnn/utils.h' l='162'>/*
 * \brief Fixed point multiplication between integer tensor with floating point
 * scalar. This implementation rounds  to the nearest value when it is midway
 * between two representable values.
 * \param tensor The quantized input tensor of dtype int64.
 * \param multiplier The scalar multiplier.
 * \param input_shape Shape of the input tensor.
 * \return The sequence of Relay ops for fixed point multiplication with TONEARES rounding.

 * \note Original compuation is scale_fp32 * quantized_tensor.  To convert into
 *       integer computation, the multiplication with fp32 scalar can be
 *       replaced by multiplication with an int value and then right shifting
 *       the result. This approximates the floating point computation with a
 *       fixed point computation.
 *
 *       Computation of fixed point multiplication is consist of following
 steps:
 *       1) Multiply the fixed point multiplier with quantized tensor.
 *       2) Round the result.
 *       3) Right shift the result
 */</doc>
<use f='tvm/src/relay/qnn/op/requantize.cc' l='241' u='c' c='_ZN3tvm5relay3qnn18RequantizeLowerIntERKNS_9RelayExprES4_S4_S4_S4_PKNS1_15RequantizeAttrsERKNS_7runtime5ArrayINS_8PrimExprEvEERKNS8_8DataTypeE'/>
<def f='tvm/src/relay/qnn/utils.cc' l='59' ll='109' type='tvm::relay::Expr tvm::relay::qnn::FixedPointMultiplyToNearest(tvm::relay::Expr tensor, double multiplier, const Array&lt;tvm::relay::IndexExpr&gt; &amp; input_shape)'/>
<use f='tvm/src/relay/quantize/realize.cc' l='84' u='c' c='_ZN3tvm5relay8quantize9MulAndDivENS_9RelayExprEffNS_7runtime8DataTypeERKNS3_5ArrayINS_8PrimExprEvEE'/>
<use f='tvm/src/relay/quantize/realize.cc' l='142' u='c' c='_ZN3tvm5relay8quantize15QuantizeRealizeERKNS0_4CallERKNS_7runtime5ArrayINS_9RelayExprEvEERKNS5_9ObjectRefE'/>
