<dec f='tvm/src/tir/schedule/analysis.h' l='624' type='std::tuple&lt;bool, bool, bool, bool, bool, bool&gt; tvm::tir::AnalyzeReadWritePattern(const tvm::tir::BufferRegion &amp; read_region, const tvm::tir::BufferRegion &amp; write_region)'/>
<doc f='tvm/src/tir/schedule/analysis.h' l='601'>/*!
 * \brief Given the read/write region, extract the pattern of their index correspondence
 * namely, the mapping from read index to the write index.
 * \param read_region The read region
 * \param write_region The write region
 * \return A tuple of booleans, the extracted pattern
 * 0) exists: if the pattern is found
 * 1) surjective: if the pattern is surjective, i.e. each write index is mapped at least once
 *    e.g. A[i, j] = B[i, i, j]
 * 2) injective: if the pattern is injective, i.e. each write index is mapped at most once.
 *    e.g. A[i, j] = B[i]
 * 3) ordered: if the mapping is ordered
 * 4) no_const_read: if there is no constant indexing in the read indices,
 *    e.g. A[i, j] = B[0, i, j]
 * 5) no_shift_read: if there is no constant shift in the read indices,
 *    e.g. A[i, j] = B[i + 1, j]
 */</doc>
<doc f='tvm/src/tir/schedule/analysis.h' l='618'>/*exists=*/</doc>
<use f='tvm/src/meta_schedule/schedule_rule/auto_inline.cc' l='124' u='c' c='_ZN3tvm13meta_schedule14AutoInlineNode11CheckInlineERKNS_3tir8ScheduleERKNS2_7BlockRVE'/>
<use f='tvm/src/tir/schedule/analysis/analysis.cc' l='562' u='c' c='_ZN3tvm3tir12IsWriteCacheERKNS0_8StmtSRefE'/>
<def f='tvm/src/tir/schedule/analysis/analysis.cc' l='1817' ll='1897' type='std::tuple&lt;bool, bool, bool, bool, bool, bool&gt; tvm::tir::AnalyzeReadWritePattern(const tvm::tir::BufferRegion &amp; read_region, const tvm::tir::BufferRegion &amp; write_region)'/>
<doc f='tvm/src/tir/schedule/analysis/analysis.cc' l='1817'>/*exists=*/</doc>
