<dec f='tvm/include/tvm/runtime/logging.h' l='150'/>
<doc f='tvm/include/tvm/runtime/logging.h' l='104'>/*!
 * \brief COND_X calls COND_X_N where N is the number of parameters passed to COND_X
 * X can be any of CHECK_GE, CHECK_EQ, CHECK, or LOG COND_X (but not COND_X_N)
 * are supposed to be used outside this file.
 * The first parameter of COND_X (and therefore, COND_X_N), which we call &apos;quit_on_assert&apos;,
 * is a boolean. The rest of the parameters of COND_X is the same as the parameters of X.
 * quit_on_assert determines the overall behavior of COND_X. If it&apos;s true COND_X
 * quits the program on assertion failure. If it&apos;s false, then it moves on and somehow reports
 * the assertion failure back to the macro caller in an appropriate manner (e.g, &apos;return false&apos;
 * in a function, or &apos;continue&apos; or &apos;break&apos; in a loop)
 * The default behavior when quit_on_assertion is false, is to &apos;return false&apos;. If this is not
 * desirable, the macro caller can pass one more last parameter to COND_X to tell COND_X what
 * to do when when quit_on_assertion is false and the assertion fails.
 *
 * Rationale: These macros were designed to implement functions that have two behaviors
 * in a concise way. Those behaviors are quitting on assertion failures, or trying to
 * move on from assertion failures. Note that these macros hide lots of control flow in them,
 * and therefore, makes the logic of the whole code slightly harder to understand. However,
 * in pieces of code that use these macros frequently, it will significantly shorten the
 * amount of code needed to be read, and we won&apos;t need to clutter the main logic of the
 * function by repetitive control flow structure. The first problem
 * mentioned will be improved over time as the developer gets used to the macro.
 *
 * Here is an example of how to use it
 * \code
 * bool f(..., bool quit_on_assertion) {
 *   int a = 0, b = 0;
 *   ...
 *   a = ...
 *   b = ...
 *   // if quit_on_assertion is true, if a==b, continue, otherwise quit.
 *   // if quit_on_assertion is false, if a==b, continue, otherwise &apos;return false&apos;
 *   //   (default behaviour)
 *   COND_CHECK_EQ(quit_on_assertion, a, b) &lt;&lt; &quot;some error message when  quiting&quot;
 *   ...
 *   for (int i = 0; i &lt; N; i++) {
 *     a = ...
 *     b = ...
 *     // if quit_on_assertion is true, if a==b, continue, otherwise quit.
 *     // if quit_on_assertion is false, if a==b, continue, otherwise &apos;break&apos;
 *     //   (non-default behaviour, therefore, has to be explicitly specified)
 *     COND_CHECK_EQ(quit_on_assertion, a, b, break) &lt;&lt; &quot;some error message when  quiting&quot;
 *   }
 * }
 * \endcode
 */</doc>
