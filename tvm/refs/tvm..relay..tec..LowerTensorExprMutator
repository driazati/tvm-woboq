<inh f='tvm/src/relay/transforms/device_aware_visitors.h' l='308' c='tvm::relay::transform::DeviceAwareExprMutator'/>
<def f='tvm/src/relay/backend/te_compiler.cc' l='628' ll='946'/>
<use f='tvm/src/relay/backend/te_compiler.cc' l='951' c='_ZN3tvm5relay3tec15LowerTensorExprENS1_10TECompilerESt8functionIFvNS_8BaseFuncEEENS_17CompilationConfigE'/>
<size>328</size>
<doc f='tvm/src/relay/backend/te_compiler.cc' l='590'>/*!
 * \brief Rewrites call expressions to Relay Functions marked as &quot;primitive&quot;
 * to calls to the corresponding TIR PrimFunc for the appropriate target.
 *
 * \code
 * %0 = fn(...) { prim_op(...) }     OR   let %p = fn(...) { prim_op(...) }
 * ... %0(...) ...                        ... %p(...) ...
 * ==&gt;
 * def @q(..., target=&lt;target&gt;) { &lt;tir body&gt; }
 * ... @q(...) ...
 * \endcode
 *
 * Requires FuseOps, ToANormalForm, EtaExpand and InferType to have run.
 *
 * FuseOps is needed to identify and lift all prim op calls:
 * \code
 * ... prim_op(...) ...
 * ==&gt;
 * %0 = fn(...) { prim_op(...) }
 * ... %0(...) ...
 * \endcode
 *
 * ToANormalForm is needed so we only need to consider vars and function literals as the call
 * target.
 *
 * EtaExpand is needed to ensures all calls to primitives are direct:
 * \code
 * let %p1 = fn(...) { prim_op1(...) }
 * let %p2 = fn(...) { prim_op2(...) }
 * let %p = if (...) { %p1 } else { %p2 }
 * ... %p(...) ...
 * ==&gt;
 * let %p1 = fn(...) { prim_op1(...) }
 * let %p2 = fn(...) { prim_op2(...) }
 * let %p = fn(...) { if (...) { %p1(...) } else { %p2(...) } }
 * ... %p(...) ...
 * \endcode
 */</doc>
<fun r='_ZN3tvm5relay3tec22LowerTensorExprMutator19PreVisitLetBinding_ERKNS0_3VarERKNS_9RelayExprE'/>
<fun r='_ZN3tvm5relay3tec22LowerTensorExprMutator13PostVisitLet_EPKNS0_7LetNodeES5_'/>
<fun r='_ZN3tvm5relay3tec22LowerTensorExprMutator21DeviceAwareVisitExpr_EPKNS0_12FunctionNodeE'/>
<fun r='_ZN3tvm5relay3tec22LowerTensorExprMutator21DeviceAwareVisitExpr_EPKNS0_8CallNodeE'/>
