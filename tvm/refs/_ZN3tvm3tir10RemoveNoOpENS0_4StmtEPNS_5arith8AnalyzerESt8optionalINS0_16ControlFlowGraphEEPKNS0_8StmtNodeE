<dec f='tvm/src/tir/transforms/remove_no_op.h' l='54' type='tvm::tir::Stmt tvm::tir::RemoveNoOp(tvm::tir::Stmt stmt, arith::Analyzer * analyzer, std::optional&lt;ControlFlowGraph&gt; touch_pattern = std::nullopt, const tvm::tir::StmtNode * context = nullptr)'/>
<use f='tvm/src/tir/transforms/reduce_branching_through_overcompute.cc' l='121' u='c' c='_ZN3tvm3tir13BranchReducer10VisitStmt_EPKNS0_14IfThenElseNodeE'/>
<doc f='tvm/src/tir/transforms/remove_no_op.h' l='37'>/* \brief Remove no-ops from the statement
 *
 * Applies the same behavior as the tir.transform.RemoveNoOp pass, but
 * on a single statement, usable as a subroutine in other passes.
 *
 * \param stmt The TIR statement from which to remove no-ops
 *
 * \param analyzer The analyzer to use while proving no-ops
 *
 * \param control_flow The analyzed control-flow graph, which contains
 * the `stmt` to be analyzed.  If provided, known buffer values will
 * be used to remove no-ops.  (e.g. Removing `buf[i] = 0` in cases
 * where `buf[i]` is known to already contain zero.)  If nullptr,
 * known buffer values will not be used.
 *
 * \return The modified statement with no-ops removed
 */</doc>
<def f='tvm/src/tir/transforms/remove_no_op.cc' l='301' ll='304' type='tvm::tir::Stmt tvm::tir::RemoveNoOp(tvm::tir::Stmt stmt, arith::Analyzer * analyzer, std::optional&lt;ControlFlowGraph&gt; touch_pattern, const tvm::tir::StmtNode * context)'/>
