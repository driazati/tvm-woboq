<dec f='tvm/src/arith/transitive_comparison_analyzer.cc' l='57' type='tvm::arith::CompareResult tvm::arith::TransitiveComparisonAnalyzer::Impl::TryCompare(const tvm::PrimExpr &amp; lhs, const tvm::PrimExpr &amp; rhs, bool propagate_inequalities = true) const'/>
<use f='tvm/src/arith/transitive_comparison_analyzer.cc' l='534' u='c' c='_ZN3tvm5arith28TransitiveComparisonAnalyzer10TryCompareERKNS_8PrimExprES4_b'/>
<def f='tvm/src/arith/transitive_comparison_analyzer.cc' l='604' ll='642' type='tvm::arith::CompareResult tvm::arith::TransitiveComparisonAnalyzer::Impl::TryCompare(const tvm::PrimExpr &amp; lhs_expr, const tvm::PrimExpr &amp; rhs_expr, bool propagate_inequalities = true) const'/>
<doc f='tvm/src/arith/transitive_comparison_analyzer.cc' l='40'>/* \brief Using previously specified knowns, compare the expressions provided
   *
   * \param lhs The left-hand side of the comparison
   *
   * \param rhs The right-hand side of the comparison
   *
   * \param propagate_inequalities If true, attempt to find a sequence
   * of transitive inequalities that allow the lhs and rhs to be
   * compared.  If false, only use the known comparison that have been
   * directly provided.  Using `propagate_inequalities = false` is
   * roughly equivalent to comparing against all known values with
   * `ExprDeepEqual`, but also allowing for constant offsets on either
   * side of the inequality.
   *
   * \return The most specific result that can be proven about the
   * comparison.  If nothing can be proven, returns kUnknown.
   */</doc>
