<dec f='tvm/src/relay/collage/candidate_partition.h' l='157' type='static std::vector&lt;CandidatePartition&gt; tvm::relay::collage::CandidatePartition::MaxCoalesce(const tvm::relay::collage::DataflowGraph &amp; dataflow_graph, std::vector&lt;CandidatePartition&gt; candidates)'/>
<def f='tvm/src/relay/collage/candidate_partition.cc' l='285' ll='353' type='static std::vector&lt;CandidatePartition&gt; tvm::relay::collage::CandidatePartition::MaxCoalesce(const tvm::relay::collage::DataflowGraph &amp; dataflow_graph, std::vector&lt;CandidatePartition&gt; candidates)'/>
<doc f='tvm/src/relay/collage/candidate_partition.cc' l='284'>/*static*/</doc>
<doc f='tvm/src/relay/collage/candidate_partition.h' l='150'>/*!
   * Eagerly merge all touching candidates for the same target. The candidates must be disjoint
   * and have their Targets filled in. This is typically called on the optimal list of candidate
   * partitions found by the Collage search in order to remove unnecessary partition boundaries.
   * Ideally the search would never produce such candidates however to keep the search space
   * manageable Collage may only consider candidate partitions up to a particular depth.
   */</doc>
<use f='tvm/src/relay/collage/collage_partitioner.cc' l='268' u='c' c='_ZN3tvm5relay7collage12_GLOBAL__N_111Partitioner8FinalizeESt6vectorINS1_18CandidatePartitionESaIS5_EE'/>
