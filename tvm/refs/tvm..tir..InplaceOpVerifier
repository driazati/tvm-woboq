<inh f='tvm/include/tvm/tir/stmt_functor.h' l='299' c='tvm::tir::StmtExprVisitor'/>
<def f='tvm/src/tir/transforms/storage_rewrite.cc' l='269' ll='388'/>
<use f='tvm/src/tir/transforms/storage_rewrite.cc' l='856' c='_ZN3tvm3tir19StoragePlanRewriter10PlanMemoryERKSt6vectorINS0_25LinearAccessPatternFinder9StmtEntryESaIS4_EERKSt13unordered_mapIPKNS0_7VarNodeENS3_10Al13373811'/>
<size>56</size>
<doc f='tvm/src/tir/transforms/storage_rewrite.cc' l='243'>// Verify if the statement can be run safely via inplace fashion
//
// Detect pattern: dst[index] = f(src[index])
//
// WARNING: the current detection algorithm cannot handle the case
// when a location in an array is written multiple times
//
// For example, the following program will pass the check,
// but we cannot make A and B to be the same array.
//
//  A[0] = B[0] + 1
//  A[0] = B[0] + 1
//
// The high level code generator needs to ensure that the generated
// code only write each location of the target array once.
//
// This is the case with IR generated by the current compute schedule.
// We explicitly return false if we find there is an extern block
// which can be arbitrary IR.
//
// Neve-the-less, inplace detector should be used with care in mind.
// We may also consider introduce a condition checker that checks
// if every index only visited once for an absolute sufficient condition.
//
// The code after inplace transformation is no longer idempotent.
//</doc>
<fun r='_ZN3tvm3tir17InplaceOpVerifier9VisitStmtERKNS0_4StmtE'/>
<fun r='_ZN3tvm3tir17InplaceOpVerifier9VisitExprERKNS_8PrimExprE'/>
<fun r='_ZN3tvm3tir17InplaceOpVerifier10VisitExpr_EPKNS0_7VarNodeE'/>
<fun r='_ZN3tvm3tir17InplaceOpVerifier10VisitStmt_EPKNS0_9StoreNodeE'/>
<fun r='_ZN3tvm3tir17InplaceOpVerifier10VisitStmt_EPKNS0_15BufferStoreNodeE'/>
<fun r='_ZN3tvm3tir17InplaceOpVerifier10VisitStmt_EPKNS0_12AttrStmtNodeE'/>
<fun r='_ZN3tvm3tir17InplaceOpVerifier10VisitExpr_EPKNS0_8LoadNodeE'/>
<fun r='_ZN3tvm3tir17InplaceOpVerifier10VisitExpr_EPKNS0_14BufferLoadNodeE'/>
