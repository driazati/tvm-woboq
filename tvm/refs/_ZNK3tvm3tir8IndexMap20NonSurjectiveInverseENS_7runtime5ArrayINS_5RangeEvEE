<dec f='tvm/include/tvm/tir/index_map.h' l='215' type='std::pair&lt;IndexMap, PrimExpr&gt; tvm::tir::IndexMap::NonSurjectiveInverse(Array&lt;tvm::Range&gt; initial_ranges) const'/>
<doc f='tvm/include/tvm/tir/index_map.h' l='206'>/*! \brief Generate the inverse mapping.
   *
   * Determine the inverse, where the output range may contain
   * addresses that do not correspond to an address in the input
   * range.
   *
   * \return The inverted index map, along with the predicate for
   * which the inverse maps to a valid range.
   */</doc>
<def f='tvm/src/tir/ir/index_map.cc' l='56' ll='132' type='std::pair&lt;IndexMap, PrimExpr&gt; tvm::tir::IndexMap::NonSurjectiveInverse(Array&lt;tvm::Range&gt; initial_ranges) const'/>
<use f='tvm/src/tir/ir/index_map.cc' l='135' u='c' c='_ZNK3tvm3tir8IndexMap7InverseENS_7runtime5ArrayINS_5RangeEvEE'/>
<use f='tvm/src/tir/ir/index_map.cc' l='351' u='c'/>
<use f='tvm/src/tir/schedule/primitive/layout_transformation.cc' l='993' u='c' c='_ZN3tvm3tir15TransformLayoutENS0_13ScheduleStateERKNS0_8StmtSRefEiNS0_15BufferIndexTypeERKNS0_8IndexMapERKNS_7runtime8OptionalIS6_EE'/>
