<def f='tvm/src/tir/transforms/arg_binder.h' l='59' ll='140'/>
<size>128</size>
<doc f='tvm/src/tir/transforms/arg_binder.h' l='38'>/*!
 * \brief Helper utility to generate match and bind of arguments.
 *
 * \note There is many places in TVM IR where we need argument bindings.
 *
 *  Consider a function f(tA(shape=var(n)), tB(shape=3), tC(shape=(n+2)).
 *  Here n is a undefined variable that is decided by the outside, tB imposes
 *  a constraint such that it can only take tensor with shape 3, tC imposes
 *  another constraint that it&apos;s shape must equals n + 2.
 *  So if we call it with f(bufferA, bufferB, bufferC), we need to generate
 *  the following binding sequence:
 *  - define n = bufferA.shape[0]
 *  - assert bufferB.shape[0] == 3
 *  - assert bufferB.shape[1] == n + 3
 *
 *  In general, this is a constraint solving problem. We have simplified assumption
 *  over the binding declaration, such that we require the variable occurred in
 *  constraint must be declared in argument list. So it is illegal to have signature
 *  f(tA(shape=(n+3))) without any argument variable corresponds to n, even though
 *  it is already enough to derive n from the input argument.
 */</doc>
<fun r='_ZN3tvm3tir9ArgBinderC1EPSt13unordered_mapIPKNS0_7VarNodeENS_8PrimExprESt4hashIS5_ESt8equal_toIS5_ESaISt4pairIKS5_S6_EEE'/>
<fun r='_ZN3tvm3tir9ArgBinder4BindERKNS_8PrimExprES4_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb'/>
<fun r='_ZN3tvm3tir9ArgBinder9BindArrayERKNS_7runtime5ArrayINS_8PrimExprEvEES7_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
<fun r='_ZN3tvm3tir9ArgBinder10BindBufferERKNS0_6BufferES4_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb'/>
<fun r='_ZN3tvm3tir9ArgBinder12BindDLTensorERKNS0_6BufferERKNS_8PrimExprES7_RKNS0_3VarERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE'/>
<fun r='_ZNK3tvm3tir9ArgBinder4defsEv'/>
<fun r='_ZNK3tvm3tir9ArgBinder7assertsEv'/>
<fun r='_ZNK3tvm3tir9ArgBinder9init_nestEv'/>
<fun r='_ZNK3tvm3tir9ArgBinder16def_handle_dtypeEv'/>
<fun r='_ZN3tvm3tir9ArgBinder5Bind_ERKNS_8PrimExprES4_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEb'/>
<mbr r='tvm::tir::ArgBinder::def_map_' o='0' t='std::unordered_map&lt;const VarNode *, PrimExpr&gt; *'/>
<mbr r='tvm::tir::ArgBinder::defs_' o='64' t='std::vector&lt;Var&gt;'/>
<mbr r='tvm::tir::ArgBinder::init_nest_' o='256' t='std::vector&lt;Stmt&gt;'/>
<mbr r='tvm::tir::ArgBinder::def_handle_dtype_' o='448' t='Map&lt;tvm::tir::Var, tvm::PrimExpr&gt;'/>
<mbr r='tvm::tir::ArgBinder::asserts_' o='512' t='std::vector&lt;Stmt&gt;'/>
<mbr r='tvm::tir::ArgBinder::analyzer_' o='704' t='arith::Analyzer'/>
<use f='tvm/src/te/operation/tensor_compute_op.cc' l='186' c='_ZNK3tvm2te19TensorComputeOpNode12BuildProvideERKNS0_5StageERKSt13unordered_mapINS_3tir7IterVarENS_5RangeESt4hashIS7_ESt8equal_toIS7_ESaISt4pairIKS7_S8_EEEb'/>
<size>128</size>
<use f='tvm/src/te/operation/tensorize.cc' l='400' c='_ZN3tvm2te13MakeTensorizeEPKNS0_13ComputeOpNodeERKNS0_5StageERKSt13unordered_mapINS_3tir7IterVarENS_5RangeESt4hashIS9_ESt8equal_toIS9_ESaISt4pairIKS9_SA_EEEb'/>
<size>128</size>
<use f='tvm/src/tir/transforms/make_packed_api.cc' l='174' c='_ZN3tvm3tir13MakePackedAPIEONS0_8PrimFuncE'/>
<size>128</size>
<use f='tvm/src/tir/transforms/storage_flatten.cc' l='352' c='_ZN3tvm3tir19BufferShapeLegalize21HandleBufferBindScopeEPKNS0_12AttrStmtNodeE'/>
<use f='tvm/src/tir/transforms/storage_flatten.cc' l='1096' c='_ZN3tvm3tir19BufferBindUnwrapper21HandleBufferBindScopeEPKNS0_12AttrStmtNodeE'/>
<size>128</size>
