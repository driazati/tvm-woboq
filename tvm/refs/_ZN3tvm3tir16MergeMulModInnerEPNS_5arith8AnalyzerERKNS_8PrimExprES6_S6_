<def f='tvm/src/tir/ir/buffer.cc' l='85' ll='147' type='std::pair&lt;bool, PrimExpr&gt; tvm::tir::MergeMulModInner(arith::Analyzer * analyzer, const tvm::PrimExpr &amp; mult_expr, const tvm::PrimExpr &amp; mod_l_expr, const tvm::PrimExpr &amp; mod_r_expr)'/>
<use f='tvm/src/tir/ir/buffer.cc' l='210' u='c' c='_ZN3tvm3tir11MergeMulModEPNS_5arith8AnalyzerERKNS_8PrimExprE'/>
<doc f='tvm/src/tir/ir/buffer.cc' l='77'>// Searches for the following types of expr:
//   mult_expr = (a1 + a2 + ... + aj + c1 / (k1 * k2 * ... * ki) * k1 * ... * kt-1 ) * kt * ... * ki
//   mod_l_expr = c2
//   mod_r_expr = k1 * k2 * ... * ki
//   where c1 ~= c2 mod k1 * k2 * ... * ki
// If it can be optimized, returns (true, (a1 + a2 + ... + aj) * kt * ... * ki + c1)
// Currently the we will not search the add/mult combinations exhaustively
//   as it will take too much computation.</doc>
