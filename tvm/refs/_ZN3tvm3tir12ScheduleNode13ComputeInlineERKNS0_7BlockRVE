<dec f='tvm/include/tvm/tir/schedule/schedule.h' l='465' type='void tvm::tir::ScheduleNode::ComputeInline(const tvm::tir::BlockRV &amp; block)'/>
<doc f='tvm/include/tvm/tir/schedule/schedule.h' l='455'>/*!
   * \brief Inline a block into its consumer(s). It requires:
   * 1) The block is a complete non-root block, which only produces one buffer
   * 2) The block must not be the only leaf in the scope.
   * 3) The body of the block must be a BufferStore statement in the form of,
   *    A[i, j, k, ...] = ...
   * where the indices of the LHS are all distinct atomic variables,
   * and no variables other than those indexing variables are allowed in the statement.
   * \param block The block to be inlined to its consumer(s)
   */</doc>
<use f='tvm/src/meta_schedule/schedule_rule/auto_inline.cc' l='56' u='c' c='_ZN3tvm13meta_schedule14AutoInlineNode5ApplyERKNS_3tir8ScheduleERKNS2_7BlockRVE'/>
<use f='tvm/src/meta_schedule/schedule_rule/multi_level_tiling_tensor_core.cc' l='275' u='c' c='_ZNK3tvm13meta_schedule30MultiLevelTilingTensorCoreNode22AddReadReuseTensorCoreENS0_15TensorCoreStateE'/>
<use f='tvm/src/meta_schedule/schedule_rule/multi_level_tiling_tensor_core.cc' l='276' u='c' c='_ZNK3tvm13meta_schedule30MultiLevelTilingTensorCoreNode22AddReadReuseTensorCoreENS0_15TensorCoreStateE'/>
<use f='tvm/src/meta_schedule/schedule_rule/winograd.cc' l='29' u='c'/>
<use f='tvm/src/meta_schedule/schedule_rule/winograd.cc' l='195' u='c'/>
<use f='tvm/src/meta_schedule/schedule_rule/winograd.cc' l='212' u='c'/>
<ovr f='tvm/src/tir/schedule/concrete_schedule.cc' l='614' c='_ZN3tvm3tir20ConcreteScheduleNode13ComputeInlineERKNS0_7BlockRVE'/>
<use f='tvm/src/tir/schedule/primitive/compute_inline.cc' l='758' u='c' c='_ZN3tvm3tir19ComputeInlineTraits23UnpackedApplyToScheduleENS0_8ScheduleENS0_7BlockRVE'/>
<use f='tvm/src/tir/schedule/schedule.cc' l='193' u='a'/>
