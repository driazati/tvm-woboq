<inh f='tvm/src/relay/collage/partition_rule.h' l='162' c='tvm::relay::collage::PartitionRuleNode'/>
<def f='tvm/src/relay/collage/partition_rule.h' l='399' ll='418'/>
<use f='tvm/src/relay/collage/partition_rule.h' l='425' c='_ZNK3tvm5relay7collage20CombinePartitionRuleptEv'/>
<use f='tvm/src/relay/collage/partition_rule.h' l='425' c='_ZNK3tvm5relay7collage20CombinePartitionRuleptEv'/>
<use f='tvm/src/relay/collage/partition_rule.h' l='425' c='_ZNK3tvm5relay7collage20CombinePartitionRule3getEv'/>
<use f='tvm/src/relay/collage/partition_rule.h' l='425'/>
<size>56</size>
<doc f='tvm/src/relay/collage/partition_rule.h' l='354'>/*!
 * \brief Partition rule which combines sub-graphs to exploit optimizations commonly available in
 * backends (including the TVM lowering backend). Those optimization rules are in turn described by
 * one or more primitive \p CombinerRules.
 *
 * For TVM these primitive combiner rules are guided by the \p OpPatternKind associated with every
 * sub-graph. That in turn is the maximum of the kind of each expression node in the sub-graph,
 * using the rules:
 *  - Constants are \p kElemwise.
 *  - A call to a Relay operator has the kind of its callee.
 *  - Tuple construction and projection are injective provided all tuple fields are of tensor type.
 *  - All other sub-expressions are opaque.
 *
 * The available \p OpPatternKinds (and our abbreviations for them) are:
 *  - E: kElemWise, eg nn.relu
 *  - B: kBroadcast, eg add
 *  - I: kInjective, eg concatenate
 *  - R: kCommReduce, eg sum
 *  - A: kOutEWiseFusable, eg nn.conv2d (often called &apos;anchor nodes&apos;, hence the A abbreviation)
 *  - O: kOpaque, everything else
 * (The kTuple kind is not used by this machinery.)
 *
 * Kinds are ordered as above from least- to most-constraining w.r.t. possible partition
 * opportunities. When we write a kind abbreviation below we intend it to mean that kind *or less*.
 * And when when write &apos;kl -&gt; kr&apos; we mean it to match a sub-expression of kind kr or less who&apos;s
 * dataflow inputs are all of kind kl or less.
 *
 * We can then mimic the classic \p FuseOps TVM Pass with the following more primitive combiner
 * rules:
 *  - Sub-groups cannot have taps. In the classic \p FuseOps pass taps are avoided by construction
 *    by always considering all node-&gt;dominator paths. Here we naively allow taps on all candidates,
 *    but reject them using SubGraph::IsValid with a SubGraphConfig with allow_taps = false.
 *  - Combine A -&gt; B
 *  - Combine B -&gt; R
 *  - Combine I -&gt; I
 *  - Combine I -&gt; tuple -&gt; I. That is, if an I sub-graph has a tuple as input, and at least one
 *    tuple field can be provided by an I sub-graph exit, then both the tuple and all such fields
 *    may be joined.
 gt*
 * Note that \p FuseOps only considers the largest possible sub-graphs. However this partition rule
 * considers all possibilities so as to &apos;make room&apos; for other targets supplying other
 * overlapping candidates.
 *
 * See combiner_rule.h for the more primitive combiner rules which implement the above.
 */</doc>
<mbr r='tvm::relay::collage::CombinePartitionRuleNode::sub_rule_' o='256' t='tvm::relay::collage::PartitionRule'/>
<mbr r='tvm::relay::collage::CombinePartitionRuleNode::combiner_rules_' o='320' t='Array&lt;tvm::relay::collage::CombinerRule&gt;'/>
<mbr r='tvm::relay::collage::CombinePartitionRuleNode::max_depth_' o='384' t='size_t'/>
<fun r='_ZN3tvm5relay7collage24CombinePartitionRuleNode10VisitAttrsEPNS_11AttrVisitorE'/>
<fun r='_ZNK3tvm5relay7collage24CombinePartitionRuleNode13AllCandidatesERKNS1_13DataflowGraphERKNS1_13PartitionSpecE'/>
<fun r='_ZNK3tvm5relay7collage24CombinePartitionRuleNode15AppendBodyItemsEPSt6vectorINS_3DocESaIS4_EE'/>
<smbr r='tvm::relay::collage::CombinePartitionRuleNode::_type_key' t='const char *const'/>
<smbr r='tvm::relay::collage::CombinePartitionRuleNode::_type_final' t='const bool'/>
<smbr r='tvm::relay::collage::CombinePartitionRuleNode::_type_child_slots' t='const int'/>
<fun r='_ZN3tvm5relay7collage24CombinePartitionRuleNode16RuntimeTypeIndexEv'/>
<fun r='_ZN3tvm5relay7collage24CombinePartitionRuleNode27_GetOrAllocRuntimeTypeIndexEv'/>
<use f='tvm/src/relay/collage/partition_rule.cc' l='284'/>
<use f='tvm/src/relay/collage/partition_rule.cc' l='284'/>
<use f='tvm/src/relay/collage/partition_rule.cc' l='284'/>
<use f='tvm/src/relay/collage/partition_rule.cc' l='336' c='_ZN3tvm5relay7collage20CombinePartitionRuleC1ENS_7runtime6StringENS1_13PartitionRuleENS3_5ArrayINS1_12CombinerRuleEvEEm'/>
<size>56</size>
<fun r='_ZN3tvm5relay7collage24CombinePartitionRuleNode10VisitAttrsEPNS_11AttrVisitorE'/>
<fun r='_ZNK3tvm5relay7collage24CombinePartitionRuleNode13AllCandidatesERKNS1_13DataflowGraphERKNS1_13PartitionSpecE'/>
<fun r='_ZNK3tvm5relay7collage24CombinePartitionRuleNode15AppendBodyItemsEPSt6vectorINS_3DocESaIS4_EE'/>
